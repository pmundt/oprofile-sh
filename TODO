0.3 release
-----------

Before 1.0 big stuff
--------------------

 o can we get pre-emption up and running ?? After a first try I think it should
 be fixed by calling preempt_enable/disable before/after each op_int_operations
 allowing arch depedant stuff to not worry about preemption or at least to minmize
 things needed in arch dependant file
 o implement new pp spec
 o difference between two profile session. Difference must be made at source level. 
   (This is a part of post-prof). Difference can be made also at symbols level. Important.
 o get symbol size via elf instead of bfd ?
 o add support for samples not belonging to any symbols probably through
   artificially created symbols
 o thread profiling in the old and new flavour (2.5 introduce a new thread handling)
   - what is different ?? 
 o CPU-specific sample files option ?
 o split doc into user's manual and hacking manual, document much more 
 o auto-generate the event C files. They're too ugly. 
 
Before 1.0 little stuff
-----------------------
 
 o remove 1 and 2 magic numbers for oprof_ready
 o more discussion of problematic code needs to go in the "interpreting" section. 
 o document gcc 2.95 and linenr info problems especially for inline functions
 o make sure we behave sensibly in all places following symlinks etc. 
 o document somewhere that oprofpp -s blah will only find the first symbol
   called "blah", or fix it
 o There is probably place of post profile tools where looking at errno will give better error messages.
 o don't make hash table entries dependent on cache line size ?? 
 o op_to_source --source-dir=~moz/src/oprofile/ --output-dir=op /usr/bin/oprofiled
   will fail because the ~ is not expanded (no space around it) (popt bug I say)
 o move op_start to simple C program ??
 o should we pin rather than loop sample buffer overflow too ?
 o audit oprof_start for security + document sudo
 o coherent naming class conventions
 o use standard C integer type <stdint.h> int32_t int16_t etc.

General checks to make
----------------------
 
 o check chroot() processes and the path hash stuff
 o rgrep FIXME
 o valgrind (--show-reachable=yes --leak-check=yes)
 o audit to track unnecessary include <>
 o gcc 3.0/3.1 compile
 o Qt2/3 check, no Qt check
 o verify builds (modversions, kernel versions, athlon etc.). I have the
  necessary stuff to check kernel versions/configurations on PIII core (Phil)
 o use nm and a little script to track unused function
 o test it to hell and back
 o compile all C++ programs with STL_port and test them
 o tune memory use for module hash table use for 64 bits architecture, perhaps
  making the hash table size independant of the cache line size 

Later
-----
 
 o The halting problem: get two make cleans in a row to not compile anything
 
 o multiplexing for real
 
 o check if we can use our own RTC irq handler rather to pass through the
  the kernel service. The overhead for RTC is very big actually. Take care
  first from where come the overhead (read/write RTC CMOS is costly)

oprof_report:

IMHO this app isn't near what we really want. There's no point doing this
GUI until we can give it some real power. Let's concentrate on making the
command-line tools as good as possible first. 
- folderview of sample files + sessions in the gui itself (later ?)
- disassembly. form "+0x8b" for intra-symbol samples optionnaly, on by default?
- tune and test hotspot
- source (later ?)
 
o profile the NMI handler code
 
o merge sample files into one big report (like vtune can do repeated runs)
 
o move from racy sysctl to procfs, if it can be done nicely. Back compatibility
  probably prevents us from making a mini-filesystem.

o turn (or only compile) daemon in C++ to allow more code sharing with pp/gui
  is it a good idea ?

o negative process entries in the daemon - a fork() into the pid would always succeed,
  in the meantime count the missed samples, possibly try to get info via /proc again ...

o maybe we should support a CPU mask for enabling counters (useful with
  processor pinning ?) 

o the interrupt handler code could probably be improved by moving into asm

o we don't really need a vmlinux file during profiling ...
 
o Other x86 processors

o other processors through RTC iff we find testers
