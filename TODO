Before 1.0
----------

 o document gcc 2.95 and linenr info problems especially for inline functions
 o document somewhere that oprofpp -s blah will only find the first symbol
   called "blah" (not worth fixing) 
 o op_to_source --source-dir=~moz/src/oprofile/ --output-dir=op /usr/bin/oprofiled
   will fail because the ~ is not expanded (no space around it) 
 o get symbol size via elf instead of bfd ?
 o add support for samples not belonging to any symbols probably through
   artificially created symbols
   these two todo are perhaps worthwhile to implement now. The new filtering
   of symbols make them less interesting. - let's wait - john
 o difference between two profile session. Difference must be made at source level. 
   (This is a part of post-prof). Difference can be made also at symbols level. Important.
 o better support in post-prof for session names. Consistent cmd line interfaces - 
   this should be before 1.0 so we don't piss off users
 
 o We want to make the post-prof stuff far more flexible. See my doc in oprofile-tests
   module. So for starters we want a nice internal API for accessing info that we can
   use from a new frontend ("op_report" anyone ?)
  
   We don't want to hard code counter numbers anywhere any more. Why ? Because it
   makes multiplexing events impossible. We want things like : 

	op_start --events=CPU_CLK_UNHALTED,INST_RETIRED, ...

   An optional interface will allow you to set individual counts for each thing if we
   don't need to multiplex, else counter0 gets used as periodic timer to count the
   events. This needs a lot of changes but we should bear it in mind. 

 o move op_start to simple C program ??

 o move dev files to /dev ???
 o new tree code to replace mmap.
 o determine where we need preempt_disable/enable to prevent pre-emption + test (ugh)
 o should we pin rather than loop sample buffer overflow too ?
 o audit oprof_start for security + document sudo
 o split doc into user's manual and hacking manual, document much more 
 o op_time for only some specified files... 
 o coherent naming class conventions
 o use standard C integer type <stdint.h> int32_t int16_t etc.
	- but they are so ugly ...
 o add option to op_to_source like oprofpp -u -m on a symbol basis.
 o review the exception table of the nmi handler (at least stop oprofile)
 o more discussion of problematic code needs to go in the "interpreting" section. 
 o check chroot() processes and the path hash stuff
 o thread profiling in the old and new flavour (2.5 introduce a new thread handling)

Checks to make
--------------
 
 o audit to track unnecessary include <>
 o gcc 3.0/3.1 compile. (3.1 is not stable currently but I follow it, Phil)
 o verify builds (modversions, kernel versions, athlon etc.). I have the
  necessary stuff to check kernel versions/configurations on PPro core (Phil)
 o use nm and a little script to track unused function
 o test it to hell and back
 o compile all C++ programs with STL_port and test them
 
Later
-----
 
 o multiplexing for real
 
 o check if we can use our own RTC irq handler rather to pass through the
  the kernel service. The overhead for RTC is very big actually. Take care
  first from where come the overhead (read/write RTC CMOS is costly)

o move uniformly to doxygen Javadoc style :

	/**
	 * make two wheels go fast
	 * @param first first wheel
	 * @param second second wheel
	 * @return false if there were no wheels
	 */
 
- demangling automatically
 
oprof_report:

IMHO this app isn't near what we really want. There's no point doing this
GUI until we can give it some real power. Let's concentrate on making the
command-line tools as good as possible first. 
- folderview of sample files + sessions in the gui itself (later ?)
- disassembly. form "+0x8b" for intra-symbol samples optionnaly, on by default?
- tune and test hotspot
- source (later ?)
 
o profile the NMI handler code
 
o merge sample files into one big report (like vtune can do repeated runs)
 
o move from racy sysctl to procfs, if it can be done nicely

o integrate dasm, probably the best way is to allow to fall back to objdump.

o turn (or only compile) daemon in C++ to allow more code sharing with pp/gui
  is it a good idea ?

o negative process entries in the daemon - a fork() into the pid would always succeed,
  in the meantime count the missed samples, possibly try to get info via /proc again ...

o maybe we should support a CPU mask for enabling counters (useful with
  processor pinning ?) 

o the interrupt handler code could probably be improved by moving into asm

o we don't really need a vmlinux file during profiling ...
 
o Other x86 processors

o other processors through RTC iff we find testers
